#!/usr/bin/env python

__version_major__ = 1
__version_minor__ = 0
__revision__ = 1
__build__ = ""

import optparse
import sys, os
import csv, re
import urllib2, binascii

p = optparse.OptionParser(description = """color-KEGG-pathway: Color objects
(genes, compounds or sub-pathways) in a graphical representation of KEGG
pathways, and display the result as a .png file (one file per pathway)""")

g = optparse.OptionGroup(p, "Input and output")

g.add_option("-i", "--input", dest = "input_fn", metavar = "FILENAME",
	help = """(mandatory) Name of the input .csv-formatted file containing the
pathway identifiers (first column), object identifiers (second column) and
hex-encoded colors for the background (third column).""")

g.add_option("-o", "--output-path", dest = "output_path", metavar = "PATH", default = '.',
	help = """(optional) Path to the folder in which the output .png file(s)
will be saved (one file per pathway).""")

p.add_option_group(g)

g = optparse.OptionGroup(p, "Color gradients")

g.add_option("--two-color-scale", dest = "two_color_scale", nargs = 2, metavar = "MINIMUM MAXIMUM",
	help = """If set, will handle the third column in the input file as a
measure rather than a color. The actual color will be calculated as a linear
interpolation between the start and end color of a gradient. You must provide
the minimum and maximum value used to perform this interpolation. 'min' or 'max'
can be used as placeholders for the minimum and maximum value found in the input
file, respectively.""")

g.add_option("--three-color-scale", dest = "three_color_scale", nargs = 3, metavar = "MINIMUM MIDPOINT MAXIMUM",
	help = """If set, will handle the third column in the input file as a
measure rather than a color. The actual color will be calculated as a linear
interpolation between the midpoint color and the end color (if the value is
above the midpoint) or between the midpoint color and the start color (if the
value is below the midpoint). 'min' or 'max' can be used as placeholders for
the minimum and maximum value found in the input file, respectively.""")

g.add_option("--start-color", dest = "start_color", metavar = "R G B", type = "int", nargs = 3, default = (0, 255, 0),
	help = """(optional) First color of the gradient, as a 255-based RGB
definition. Will be used to represent the lowest value in the input file. Only
considered when using '--two-color-scale' or '--three-color-scale'. Default:
0 255 0 (green).""")

g.add_option("--midpoint-color", dest = "midpoint_color", metavar = "R G B", type = "int", nargs = 3, default = (0, 0, 0),
	help = """(optional) Midpoint color of the gradient, as a 255-based RGB
definition. Will be used to represent the midpoint value in the input file. Only
considered when using '--three-color-scale'. Default: 0 0 0 (black).""")

g.add_option("--end-color", dest = "end_color", metavar = "R G B", nargs = 3, type = "int", default = (255, 0, 0),
	help = """(optional) Last color of the gradient, as a 255-based RGB
definition. Will be used to represent the highest value in the scale. Only
considered when using '--two-color-scale' or '--three-color-scale'. Default:
255 0 0 (red).""")

p.add_option_group(g)

g = optparse.OptionGroup(p, "Concurrent values")

g.add_option("--aggregate", dest = "aggregation_strategy", metavar = "STRING",
	choices = ("highest_magnitude", "max_value", "min_value", "mean_value", "median_value", "average_color"),
	help = """(optional) Strategy to use to deal with concurrent values. I.e.,
cases where a single graphical element is defined by more than one object with
different values. 'highest_magnitude' will interpret the third column in the
input file as a measure, and select the color associated with the measure of
highest magnitude (either in the positives or negatives) among all objects
associated to this element. 'max_value', 'min_value', 'median_value' and
'mean_value' will interpret the third column in the input file as a measure,
and calculate the color of the maximum value, minimum value, median or mean
value, respectively. 'average_color' will calculate an average color from the
colors of all objects associated to this element. Default: 'highest_magnitude'
when using '--two-color-scale' or '--three-color-scale', else 'average_color'.""")

p.add_option_group(g)

g = optparse.OptionGroup(p, "Missing values")

g.add_option("--missing-color", dest = "missing_color", metavar = "R G B", nargs = 3, type = "int", default = (200, 200, 200),
	help = """(optional) Color to be used to represent missing values; i.e.,
objects present in the pathway for which no color or expression level was
provided. Default: 200 200 200 (light gray).""")

g.add_option("--dont-show-missing", dest = "exclude_missing", metavar = "TYPE", action = "append",
	help = """(optional) Type of objects that should not be painted with the
missing value color if not declared in the input file. Accepted values are
'compound', 'genes', 'ortholog' and 'map'. This option can be used multiple
times.""")

g.add_option("--only-show-missing", dest = "only_exclude", metavar = "TYPE",
	help = """(optional) Only allow objects of a given type to be painted with
the missing color if not declared in the input file. Accepted values are
'compound', 'genes', 'ortholog' and 'map'. Override the '--dont-show-missing'
option.""")

p.add_option_group(g)

g = optparse.OptionGroup(p, "Additional options")

g.add_option("--no-legend", dest = "add_legend", action = "store_false", default = True,
	help = "If set, will not insert a legend of the color scale in the picture")

#g.add_option("--create-contact-sheet", dest = "create_contact_sheet", action = "store_true", default = False,
#	help = """If set, will create a .pdf file along with the .png file with a
#list of the genes and their final colors""")

p.add_option_group(g)

p.add_option("-v", "--version", dest = "display_version", action = "store_true", default = False,
	help = "show the program version and exit")

(p, a) = p.parse_args()

def error (msg):
	print >>sys.stderr, "ERROR: %s" % msg
	sys.exit(1)

if (p.display_version):
	print "%s.%srev%s" % (__version_major__, __version_minor__, __revision__)
	sys.exit(0)

try:
	import suds
except:
	error("The SUDS library (http://fedorahosted.org/suds/) is required.")

try:
	import pyx
except:
	error("The PyX library (http://pyx.sourceforge.net/) is required.")

try:
	import Image as pil
	import ImageDraw as pil_draw
except:
	error("The Python Imaging Library (http://www.pythonware.com/products/pil/) is required.")

if (not p.input_fn):
	error("An input file is required.")

if (not os.path.exists(p.input_fn)):
	error("File '%s' not found." % p.input_fn)

if (p.exclude_missing):
	p.exclude_missing = [item.lower() for item in p.exclude_missing]
else:
	p.exclude_missing = []

if (p.only_exclude):
	p.exclude_missing = filter(lambda x: x != p.only_exclude.lower(), ("compound", "gene", "ortholog", "map"))

if (not p.aggregation_strategy):
	if (p.two_color_scale or p.three_color_scale):
		p.aggregation_strategy = "highest_magnitude"
	else:
		p.aggregation_strategy = "average_color"

print "Reading '%s'" % p.input_fn

pathway_id_pattern = re.compile("[a-z]+[0-9]{5}")

content = {}
for entry in csv.reader(open(p.input_fn, 'rU')):
	if (len(entry) != 3):
		error("Invalid input file: each line must contains three values.")

	pathway_id, object_id, value = entry
	if (not pathway_id_pattern.match(pathway_id)):
		error("Invalid input file: invalid pathway identifier '%s'." % pathway_id)

	if (not pathway_id in content):
		content[pathway_id] = []

	content[pathway_id].append((object_id, value))

print "  number of pathways to color: %s (%s)" % (len(content), ', '.join(sorted(content)))

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# create a PyX color object from a 0-255 based RGB definition
def rgb (channels, name):
	try:
		r, g, b = channels
		assert (r >= 0) and (r <= 255), "Red channel must be between 0 and 255"
		assert (g >= 0) and (g <= 255), "Green channel must be between 0 and 255"
		assert (b >= 0) and (b <= 255), "Blue channel must be between 0 and 255"

		return pyx.color.rgb(r = r / 255.0, g = g / 255.0, b = b / 255.0)

	except Exception as msg:
		error("Invalid %s color: %s" % (name, msg))

decimal_to_hex = lambda x: ("%x" % x).zfill(2)

# transform a 0-1 based RGB color into a HTML representation
def rgb_to_html (rgb):
	return '#' + \
		decimal_to_hex(255 * rgb.color["r"]) + \
		decimal_to_hex(255 * rgb.color["g"]) + \
		decimal_to_hex(255 * rgb.color["b"])

# calculate the color with the highest contrast with 'rgb'
def contrast (rgb):
	if (rgb.hsb().color["b"] <= 0.7):
		return pyx.color.rgb(0.99, 0.99, 0.99) # not quite white, as its support appears buggy with KEGG api
	else:
		return pyx.color.rgb.black

if (p.two_color_scale or p.three_color_scale):
	start_color = rgb(p.start_color, "start")
	end_color = rgb(p.end_color, "end")

	# get the minimum and maximum value
	m, M = sys.maxint, -sys.maxint
	for pathway_id in content:
		for object_id, value in content[pathway_id]:
			try:
				value = float(value)
			except:
				error("Invalid input file: Invalid value '%s'" % value)

			if (value < m):
				m = value
			if (value > M):
				M = value

	box = lambda x: min(max(x, 0), 1)

# interpolation of a user-provided value into a 3-color scale
if (p.three_color_scale):
	midpoint_color = rgb(p.midpoint_color, "midpoint")
	min_value, midpoint_value, max_value = p.three_color_scale

	try:
		if (min_value.lower() == "min"):
			min_value = m
		else:
			min_value = float(min_value)

		if (max_value.lower() == "max"):
			max_value = M
		else:
			max_value = float(max_value)

		midpoint_value = float(midpoint_value)

	except ValueError as msg:
		error("Invalid parameter: Invalid value '%s'" % str(msg).split(':', 1)[1].strip())

	if (midpoint_value >= max_value):
		error("The midpoint value must be below the maximum value")

	if (min_value >= midpoint_value):
		error("The minimum value must be below the midpoint value")

	if (M > max_value):
		error("The maximum value in the input file is higher than the maximum value provided for the color scale")

	if (m < min_value):
		error("The minimum value in the input file is lower than the minimum value provided for the color scale")

	lower_gradient = pyx.color.lineargradient(start_color, midpoint_color)
	upper_gradient = pyx.color.lineargradient(midpoint_color, end_color)

	lower_transform = lambda x: (x - min_value) / (midpoint_value - min_value)
	upper_transform = lambda x: (x - midpoint_value) / (max_value - midpoint_value)

	def color (value):
		value = float(value)
		if (value > midpoint_value):
			return upper_gradient.getcolor(box(upper_transform(value)))
		else:
			return lower_gradient.getcolor(box(lower_transform(value)))

	def add_legend (fn):
		image = pil.open(fn)
		width, height = image.size

		image_ = pil.new("RGB", (width + 40, height), "white")
		image_.paste(image, (40, 0))

		draw = pil_draw.Draw(image_)
		draw.rectangle((40, 0, width + 40 - 1, height - 1), fill = None, outline = "white")

		x, y, p = 0, height / 2.0, 0

		for value in range(0, 100):
			draw.rectangle((x, y - p, x + 20, y - p + 1), fill = rgb_to_html(upper_gradient.getcolor(value / 100.0)))
			draw.rectangle((x, y + p, x + 20, y + p + 1), fill = rgb_to_html(lower_gradient.getcolor(1 - value / 100.0)))
			p += 1

		offset = draw.textsize("0")[1] / 2.0

		draw.text((x + 25, y - p - offset), "%.2f" % max_value, fill = "black")
		draw.text((x + 25, y - offset), "%.2f" % midpoint_value, fill = "black")
		draw.text((x + 25, y + p - offset), "%.2f" % min_value, fill = "black")

		image_.save(fn, "PNG")

# interpolation of a user-provided value into a 2-color scale
elif (p.two_color_scale):
	min_value, max_value = p.two_color_scale

	try:
		if (min_value.lower() == "min"):
			min_value = m
		else:
			min_value = float(min_value)

		if (max_value.lower() == "max"):
			max_value = M
		else:
			max_value = float(max_value)

	except ValueError as msg:
		error("Invalid parameter: Invalid value '%s'" % str(msg).split(':', 1)[1].strip())

	if (min_value >= max_value):
		error("The minimum value must be below the maximum value")

	if (M > max_value):
		error("The maximum value in the input file is higher than the maximum value provided for the color scale")

	if (m < min_value):
		error("The minimum value in the input file is lower than the minimum value provided for the color scale")

	gradient = pyx.color.lineargradient(start_color, end_color)
	transform = lambda x: (x - min_value) / (max_value - min_value)

	def color (value):
		return gradient.getcolor(box(transform(float(value))))

	def add_legend (fn):
		image = pil.open(fn)
		width, height = image.size

		image_ = pil.new("RGB", (width + 40, height), "white")
		image_.paste(image, (40, 0))

		draw = pil_draw.Draw(image_)
		draw.rectangle((40, 0, width + 40 - 1, height - 1), fill = None, outline = "white")

		x, y, p = 0, height / 2.0 + 100, 0

		for value in range(0, 200):
			draw.rectangle((x, y - p, x + 20, y - p + 1), fill = rgb_to_html(gradient.getcolor(value / 200.0)))
			p += 1

		offset = draw.textsize("0")[1] / 2.0

		draw.text((x + 25, y - p - offset), "%.2f" % max_value, fill = "black")
		draw.text((x + 25, y - offset), "%.2f" % min_value, fill = "black")

		image_.save(fn, "PNG")

# conversion of a user-defined HTML color into RGB
else:
	html_color_pattern = re.compile("[0-9a-f]{3,6}")

	def color (value):
		if (not html_color_pattern.match(value)) or (len(value) not in (3, 6)):
			error("Invalid input file: invalid color '%s'." % value)

		if (len(value) == 3):
			channels = [int(v + v, 16) for v in value]
		else:
			channels = [int(value[i:i+2], 16) for i in (0, 2, 4)]

		return rgb(channels, "user-provided")

bg_missing_color = rgb(p.missing_color, "missing color")
fg_missing_color = contrast(bg_missing_color)

def mean (values):
	return sum(values) / float(len(values))

def median (values):
	values_, n = sorted(values), len(values)
	p = n / 2
	if ((n % 2) == 0):
		return (values_[p-1] + values_[p]) / 2.0
	else:
		return values_[p]

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

try:
	connection = suds.client.Client("http://soap.genome.jp/KEGG.wsdl").service

	for pathway_id in sorted(content):
		print "\nConstructing picture for pathway %s" % pathway_id

		print "  requesting pathway content from KEGG ..."

		# ask for all the objects and graphical elements in this pathway
		object_list, object2elements, element2objects, element2type = {}, {}, {}, {}

		for entry in connection.get_elements_by_pathway("path:" + pathway_id):
			element_id = int(entry["element_id"])

			for object_id in entry["names"]:
				# storing a hash of this object name together with its real name
				object_id_ = object_id.lower()
				object_list[object_id_] = object_id

				# storing the element(s) for this object
				if (not object_id_ in object2elements):
					object2elements[object_id_] = {}
				object2elements[object_id_][element_id] = True

				# storing the object(s) for this element
				if (not element_id in element2objects):
					element2objects[element_id] = {}
				element2objects[element_id][object_id_] = True

			element2type[element_id] = str(entry["type"])

		# check and aggregate objects in the input file by graphical elements
		element_list = {}

		for (object_id, value) in content[pathway_id]:
			object_id_ = object_id.lower() # lower-case version to allow case-insensitive comparisons

			# if this object is not known to belong to
			# this pathway, we report it as an error
			if (not object_id_ in object_list):
				error("Unknown object '%s' in pathway %s." % (object_id, pathway_id))

			# we store this object under its element(s) ID
			for element_id in object2elements[object_id_]:
				if (not element_id in element_list):
					element_list[element_id] = {}

				element_list[element_id][object_id_] = value

		# determine the colors of each graphical element
		element_list_, fg_color_list, bg_color_list = [], [], []

		for element_id in sorted(element_list):
			objects = element_list[element_id]

			# simplest case: only one object is behind this graphical element
			if (len(objects) == 1):
				bg_color = color(objects.values()[0])

			# aggregation by calculation of an average color
			elif (p.aggregation_strategy == "average_color"):
				try:
					bg_colors = [color(value) for value in objects.values()]
				except:
					error("The 'average_color' aggregation strategy can only be used when object values are colors.")

				r, g, b = [], [], []

				for bg_color in bg_colors:
					r.append(bg_color.color["r"])
					g.append(bg_color.color["g"])
					b.append(bg_color.color["b"])

				bg_color = pyx.color.rgb(
					r = mean(r),
					g = mean(g),
					b = mean(b)
				)

			# aggregation by selection of the min, max, mean or median value
			else:
				try:
					values = [float(v) for v in objects.values()]
				except:
					error("The '%s' aggregation strategy can only be used when object values are measures, not colors." % p.aggregation_strategy)

				if (p.aggregation_strategy == "highest_magnitude"):
					if (max(values) >= abs(min(values))):
						bg_color = color(max(values))
					else:
						bg_color = color(min(values))

				elif (p.aggregation_strategy == "max_value"):
					bg_color = color(max(values))

				elif (p.aggregation_strategy == "min_value"):
					bg_color = color(min(values))

				elif (p.aggregation_strategy == "mean_value"):
					bg_color = color(mean(values))

				elif (p.aggregation_strategy == "median_value"):
					bg_color = color(median(values))

			element_list_.append(element_id)
			fg_color_list.append(contrast(bg_color))
			bg_color_list.append(bg_color)

		# check if there are elements with no associated value in the input file
		missing_objects = {}

		for element_id in element2objects:
			# if this element is missing and its type has been authorized
			# by the user to be painted with the missing color, we report it
			if (not element_id in element_list) and (not element2type[element_id] in p.exclude_missing):
				for object_id_ in element2objects[element_id]:
					missing_objects[object_list[object_id_]] = True

				element_list_.append(element_id)
				fg_color_list.append(fg_missing_color)
				bg_color_list.append(bg_missing_color)

		if (len(missing_objects) > 0):
			print "    %s object%s with no value nor color provided:" % (
				len(missing_objects),
				{True: 's', False: ''}[len(missing_objects) > 1],
			)
			for object_id in sorted(missing_objects):
				print "      %s" % object_id

		print "  requesting colored pathway from KEGG ..."

		# see http://www.genome.jp/kegg/soap/doc/keggapi_manual.html#label:77
		url = connection.color_pathway_by_elements(
			pathway_id = pathway_id,
			element_list = element_list_,
			fg_color_list = [rgb_to_html(c) for c in fg_color_list],
			bg_color_list = [rgb_to_html(c) for c in bg_color_list]
		)

		print "  downloading the resulting picture ..."
		response = urllib2.urlopen(url)

		fn = os.path.join(p.output_path, "%s.png" % pathway_id)
		o = open(fn, 'wb')
		o.write(response.read())
		o.close()

		if (p.add_legend) and (p.two_color_scale or p.three_color_scale):
			print "  adding legend ..."
			add_legend(fn)

		print "  done (saved as %s)" % fn
		"""
		if (p.create_contact_sheet):
			print "  creating contact sheet ..."

			canvas = pyx.canvas.canvas()
			pyx.text.set(mode = "latex")

			y = 0
			for i, (object_id, value) in enumerate(content[pathway_id]):
				canvas.fill(pyx.path.rect(0, y, 3, 0.5), [bg_color_list[i]])

				canvas.text(
					1.5, y + 0.25,
					pyx.text.escapestring(str(value)),
					[fg_color_list[i], pyx.text.valign.middle, pyx.text.halign.center]
				)

				canvas.text(
					3.25, y + 0.5,
					"\\textbf{%s}" % pyx.text.escapestring(object_id),
					[pyx.text.valign.middle]
				)

				r = int(bg_color_list[i].color["r"] * 255)
				g = int(bg_color_list[i].color["g"] * 255)
				b = int(bg_color_list[i].color["b"] * 255)

				canvas.text(
					3.25, y,
					pyx.text.escapestring("RGB: %s %s %s, HTML: %s" % (r, g, b, rgb_to_html(bg_color_list[i]))),
					[pyx.color.gray(0.5)]
				)

				y -= 1

			fn = os.path.join(p.output_path, "%s.pdf" % pathway_id)
			canvas.writePDFfile(fn)

			print "  done (saved as %s)" % fn
		"""

except Exception as msg:
	error(str(msg))
